\documentclass[a4paper,12pt]{article}	% тип документа

\usepackage[a4paper,top=1.3cm,bottom=2cm,left=1.5cm,right=1.5cm,marginparwidth=0.75cm]{geometry} % field settings

\usepackage[T2A]{fontenc}		% кодировка
\usepackage[utf8]{inputenc}		% кодировка исходного текста
\usepackage[english,russian]{babel}	% локализация и переносы
\usepackage{indentfirst}

%Piece of code
\usepackage{listings}
\usepackage{xcolor}
\lstset
{
    language=C++,
    backgroundcolor=\color{black!4}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

%Drawings
\usepackage{graphicx}

\usepackage{wrapfig}

\usepackage{multirow}

\usepackage{float}

\usepackage{wasysym}

\usepackage[T1]{fontenc}
\usepackage{titlesec}

\setlength{\parindent}{3ex}

%Quatation
\usepackage{csquotes}

% Literature
\addto\captions{\def\refname{Literature.}}

%Header
\title{
	\center{\textbf{CQ 21.}}
	}


\begin{document}	% the beginning of the document

\maketitle


\section{Какие средства используются для организации межпроцессного взаимодействия?}
	
	Межпроцессное взаимодействие (IPC) -- это механизм, который позволяет процессам взаимодействовать друг с другом и синхронизировать свои действия. Реализуется посредством механизмов, предоставляемых ядром ОС или процессом, использующим механизмы ОС и реализующим новые возможности IPC. Для организации IPC используются (рассматриваем IPC в рамках одной ОС):
	
	\begin{itemize}
	
		\item Shared memory (разделяемая память) (см. подробности в следующем вопросе).
		
		\item Memory-mapped files (см. подробности в следующем вопросе).
		
		\item Messaging passing (обмен сообщениями). Два взаимодействующих процесса устанавливают канал связи и обмениваются сообщениями с помощью базовых примитивов: send() и receive(). Как правило, организация отправления сообщений основана на FIFO-принципе.
			
	\end{itemize}
	
	P.s. В конспекте есть также "запись на диск пакетами или после flush" (дополнительный материал).
	
\section{Чем файлы, отображаемые в память, отличаются от разделяемой памяти?}

	Shared memory (разделяемая память) -- это самый быстрый способ IPC, т.к. обмен данными осуществляется через общую для процессов часть памяти без использования системных вызовов ядра. Состоит в том, что сегмент разделяемой памяти создаётся и подключается ОС в свободную часть АП указанного процесса. Однако, shared memory требует реализации синхронизации для различных процессов. 
	
	Memory-mapped files (файлы, отображаемые в память) подразумевают, что часть АП процесса ассоциируется с некоторым существующим файлом, а затем данный файл может быть использован для IPC и работы с самим файлом. Однако поскольку управление файлом происходит на уровне filesystem, то данное средство организации IPC является более медленным.
	
\section{Что необходимо учитывать при создании контейнеров в разделяемой памяти?}

	При создании контейнеров разделяемой памяти (или отображаемых в память файлов) при использовании средств Boost.Interprocess необходимо учитывать, что они, не могут предполагать ни одного из следующих соглашений/ограничений Стандарта (для обычных контейнеров):
	
	\begin{itemize}
	
		\item допустимости, что typedef указателя на аллокатор для каждого аллокатора является синонимом T*.

		\item допустимости, что все объекты-аллокаторы одного и того же типа эквивалентны и всегда являются равными.
		
	\end{itemize}		
	
	Первое недопустимо, т.к. иначе нельзя будет использовать умные указатели как allocator::pointer. Второй недопустим, т.к. аллокаторы одного типа, выделяющие память в разных адресных пространствах, будут считаться одинаковыми.
	
	Поэтому контейнеры, которые мы хотим поместить в разделяемую память или отображаемые в память файлы (при использовании Boost.Interprocess) таковы, что:
	
	\begin{itemize}
	
		\item НЕ могут предполагать, что память, выделенная с помощью аллокатора, может быть освобождена другими аллокаторами того же типа. Все объекты-аллокаторы должны совпадать только в том случае, если память, выделенная для одного объекта, может быть освобождена другим, что следует проверять лишь использованием operator==() во время выполнения.
		
		\item Их внутренние указатели должны иметь тип allocator::pointer, и контейнеры не могут предполагать, что allocator::pointer является необработанным указателем (не является умным указателем).
		
		\item Все контейнерные объекты должны быть сконструированы/уничтожены с помощью функций allocator::construct/allocator::destroy.
	
	\end{itemize}
	
	Итак, контейнеры Boost.Interprocess размещаются в разделяемой памяти или отображаемых в память файлых и т.д. с использованием двух механизмов:
	
	\begin{itemize}

		\item Boost.Interprocess construct<>, find\_or\_construct<>... функций. Эти функции размещают объекты C++ в разделяемой памяти или отображаемых в память файлых. Но они размещают лишь объекты, но не другие данные, которые могут быть динамически аллоцированы уже самими объектами.
		
		\item Shared memory allocators (аллокаторы разделяемой памяти). Они позволяют выделять разделяемую память или части отображаемых в память файлов так, что созданные контейнеры могут динамически аллоцировать память для хранения новых и новых элементов.
	
	\end{itemize}
	
	Это означает что для размещения какого-либо Boost.Interprocess контейнера в разделяемой памяти или в отображаемых в память файлых, контейнер должен:

	\begin{itemize}

		\item Вывести тип шаблонного параметра аллокатора как некоторого Boost.Interprocess аллокатора.
		
		\item Принимать в качестве параметра Boost.Interprocess аллокатор.
		
		\item Использовать сonstruct<>/find\_or\_construct<>... функции для размещения контейнера в управляемой памяти.
	
	\end{itemize}
	
\section{Чем отличаются анонимные и именованные примитивы синхронизации?}

	При использовании именованных примитивов синхронизации для создания какого-либо объекта и последующей работы с ним процессы используют его имя. Это похоже на создание или открытие файлов: например, процесс создает файл, используя класс fstream с именем файла filename, а другой процесс открывает этот файл, используя другой процесс fstream с тем же аргументом имени файла. Т.о., каждый процесс использует свой объект для доступа к ресурсу, но оба процесса используют один и тот же базовый ресурс. Работой же именованных принципов синхронизации управляет ОС. Преимущество именованных утилит состоит в том, что их легче обрабатывать для простых задач синхронизации, так как обоим процессам не нужно создавать разделяемую область памяти и создавать там механизм синхронизации.
	
	При использовании анонимных примитивов синхронизации процессы совместно используют один и тот же объект через общую память или файлы отображения памяти (т.е. объекты хранятся в разделяемой памяти или в файлых отображения памяти). Это похоже на традиционные объекты синхронизации потоков (например, мьютексы): оба процесса совместно используют один и тот же объект. Но в отличие от синхронизации потоков, где, например, глобальные переменные и память кучи могут совместно использоваться потоками одного и того же процесса, совместное использование объектов между двумя потоками из разных процессов возможно только через сопоставленные области, которые отображают один и тот же сопоставляемый ресурс (например, общую память или отображаемые файлы памяти). Анонимные утилиты могут быть сериализованы на диск при использовании отображаемых в память объектов, обеспечивающих автоматическое сохранение утилит синхронизации. Можно создать утилиту синхронизации в файле отображения памяти, перезагрузить систему, снова отобразить файл и снова использовать утилиту синхронизации без каких-либо проблем. Этого нельзя добиться с помощью именованных утилит синхронизации.

		Основное различие интерфейса между именованными и анонимными примитивами синхронизации заключается в конструкторах. Обычно анонимные утилиты имеют только один конструктор, тогда как именованные утилиты имеют несколько конструкторов, первый аргумент которых представляет собой специальный тип, который запрашивает создание, открытие или открытие или создание базового ресурса.
		
\section{Как могут быть организованы библиотеки динамической компоновки DLL?}
	
	Dynamic Link Library (DLL) -- библиотека динамической компоновки / динамически подключаемая библиотека -- динамическая библиотека, позволяющая многократное использование кода или данных различными программными приложениями. Практически невозможно создать приложение Windows, в котором не использовались бы библиотеки DLL. В DLL содержатся все функции Win32 API и несчётное количество других функций операционных систем Win32.	
	
	Библиотеки DLL выполняются в пространстве памяти вызывающего процесса и с теми же правами доступа, что означает, что при их использовании возникают небольшие накладные расходы, но также и то, что вызывающая программа не защищена, если в библиотеке DLL есть какая-либо ошибка. Иными словами, DLL -- это просто наборы функций, собранные в библиотеки. Однако, в отличие от своих статических родственников (файлов .lib), библиотеки DLL не присоединены непосредственно к выполняемым файлам с помощью редактора связей. В выполняемый файл занесена только информация об их местонахождении.
	
	Чаще всего проект подключается к DLL статически, или неявно, на этапе компоновки. Загрузкой DLL при выполнении программы управляет ОС. Однако, DLL можно загрузить и явно, или динамически, в ходе работы приложения.
	
	Некоторые преимущества DLL:
	
	\begin{itemize}

		\item Использование меньшего количества ресурсов.
		
		\item Модульность архитектуры.
		
		\item Упрощение развёртывания и установки.
	
	\end{itemize}

	Эти	преимущества позволяют создавать и использовать DLL патчи, которые способствуют оперативному или динамическому обновлению программного обеспечения, представляющему собой применение исправлений без выключения и перезапуска системы или соответствующей программы.

	Тем не менее библиотеки DLL являются ядром архитектуры Windows, у них есть несколько недостатков, которые в совокупности составляют т.н. DLL Hell.

\newpage

	
\addcontentsline{toc}{section}{Literature}
 
	\begin{thebibliography}{}
	
		\bibitem{litlink1} Конспект. И.С. Макаров.
		\bibitem{litlink2} https://www.boost.org/doc/libs/1\_81\_0/doc/html/interprocess.html\#interprocess.intro
		\bibitem{litlink3} https://learn.microsoft.com/en-us/troubleshoot/windows-client/deployment/dynamic-link-library
		\bibitem{litlink4} https://en.wikipedia.org/wiki/Dynamic-link\_library
		\bibitem{litlink5} http://www.cyberguru.ru/programming/visual-cpp/visual-cpp-beginners.html?showall=\&start=29
		
	\end{thebibliography}


\end{document} % end of the document
